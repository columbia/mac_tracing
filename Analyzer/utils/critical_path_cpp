#include "critical_path.hpp"

CriticalPath::CriticalPath(Graph *_graph, Node *root, Node *end)
:graph(_graph), root_node(root), end_node(end)
{
    if (root_node != nullptr && end_node != nullptr) {
        extract_path();
        save_path_to_file("critical_path.log"); 
    }
}

CriticalPath::~CriticalPath()
{
    graph = nullptr;
    root_node = nullptr;
    end_node = nullptr;
}

void CriticalPath::print_ident(int ident)
{
	//for (int i = 0; i < ident; i++) {
		//std::cout << ' ';
	//}
	std::cout << std::hex << std::left << std::setw(3) << ident;
}

bool CriticalPath::extract_path()
{
    assert(root_node && end_node);
    if (end_node == root_node) {
        std::cout << "Root and end are in the same node 0x"\
            << std::hex << root_node->get_gid() << std::endl;   
        return true;
    }

    std::cout << "Begin extracting critical path from id 0x"\
         << std::hex << root_node->get_gid() << " to 0x"\
         << std::hex << end_node->get_gid() << std::endl;

    //EventBase *last_update = end_node->get_group()->contains_view_update();
    //assert(last_update);
    path = critical_path_to(0, end_node, end_node->get_group()->get_last_event()->get_abstime());
	std::cout << "Finish extracing critical path from id 0x"\
         << std::hex << root_node->get_gid() << " to 0x"\
         << std::hex << end_node->get_gid() << ", length = "\
		 << std::dec << path.size() << std::endl;
		
	return path.size() > 0;
}

bool CriticalPath::node_weight_compare(Node *elem1, Node *elem2)
{
    return elem1->time_span() > elem2->time_span();
}

bool CriticalPath::edge_weight_compare(Edge *edge1, Edge *edge2)
{
    //Node *node1 = edge1->from, *node2 = edge2->from;
    if (edge1->rel_type == WEAK_REL && edge2->rel_type != WEAK_REL)
        return false;
    //return node1->time_span() > node2->time_span();
    return edge1->get_weight() < edge2->get_weight();
}

CriticalPath::edge_map_t CriticalPath::in_edges_before_deadline(event_to_edge_map_t in_edges, double deadline)
{
    edge_map_t ret;
    event_to_edge_map_t::iterator it;

    ret.clear();
    for (it = in_edges.begin(); it != in_edges.end(); it++) {
        if (it->second->from == it->second->to)
            continue;
        if ((it->first)->get_abstime() < deadline + 0.05)
            ret[it->second] = it->first->get_group_id();
    }
    return ret;
}


std::vector<Node *> CriticalPath::sort_nodes_from_edges(edge_map_t in_edges)
{
    edge_map_t::iterator it;
    std::vector<Edge *> sorted_edges;

    for (it = in_edges.begin(); it != in_edges.end(); it++) {
        sorted_edges.push_back(it->first);
        sort(sorted_edges.begin(), sorted_edges.end(), CriticalPath::edge_weight_compare);
    }

    std::vector<Edge *>::iterator edge_it;
    std::map<Node *, bool> visited_maps;
    std::vector<Node *> candidates;

    for (edge_it = sorted_edges.begin(); edge_it != sorted_edges.end(); edge_it++) {
        if (visited_maps.find((*edge_it)->from) == visited_maps.end())
            candidates.push_back((*edge_it)->from);
        visited_maps[(*edge_it)->from] = true;
    }
#ifdef NODEWEIGHT
    sort(candidates.begin(), candidates.end(), CriticalPath::node_weight_compare);
#endif
    return candidates;   
}

std::vector<Node *> CriticalPath::add_weak_edge(int ident, Node *cur_node, double deadline)
{
    event_to_edge_map_t weak_edges = cur_node->get_in_weak_edges();
    std::vector<Node *> ret_path;
    ret_path.clear();

    if (weak_edges.size() == 0) {
		print_ident(ident);
        std::cout << "\tNo weak edge and stop searching" << std::endl; 
		Node *prev = graph->id_to_node(cur_node->get_gid() -1);
		if (prev != nullptr)
			return critical_path_to(ident + 1, prev, deadline);
        return ret_path;
    }

    event_to_edge_map_t::iterator it = weak_edges.begin();
    Node *prev_weak = it->second->from;

	print_ident(ident);
    std::cout << "\tWeak edge from 0x";
    if (prev_weak == nullptr) {
        std::cout << std::hex << weak_edges[0]->e_from->get_group_id() \
            << "to 0x" << std::hex << cur_node->get_tid() << " is not in graph\n";
        return ret_path;
    }

    //Node *prev_weak = end->prev_weak_in_thread();

    std::cout << std::hex << prev_weak->get_gid();
    std::cout << " to 0x" << std::hex << cur_node->get_gid() << std::endl;
    return critical_path_to(ident + 1, prev_weak, deadline);
}


std::vector<Node *> CriticalPath::critical_path_to(int ident, Node *cur_node, double deadline)
{
    std::vector<Node *> ret_path;
    ret_path.clear();
    if (cur_node == nullptr) {
		print_ident(ident);
        std::cout << "Path reaches nullptr" << std::endl;
        return ret_path;
    }
    
    if (cur_node->get_group()->get_last_event()->get_abstime()
        < root_node->get_group()->get_first_event()->get_abstime()) {
		print_ident(ident);
        std::cout << "Path goes over root node" << std::endl;
        return ret_path;
    }

    if (cur_node == root_node) {
        ret_path.push_back(cur_node);
		print_ident(ident);
        std::cout << "Path reaches root node" << std::endl;
        return ret_path;
    }

    edge_map_t in_edges = in_edges_before_deadline(cur_node->get_in_edges(), deadline);
    if (in_edges.size() == 0) {
        //process weak edge cases
        ret_path = add_weak_edge(ident + 1, cur_node, deadline);
        if (ret_path.size() > 0)
            ret_path.push_back(cur_node);
        return ret_path;
    }

	print_ident(ident);
    std::cout << "Number of edges to 0x" << std::hex << cur_node->get_gid()\
            << " = " << in_edges.size() << std::endl;
    
    std::vector<Node *> candidates = sort_nodes_from_edges(in_edges);
    std::vector<Node *>::iterator node_it;
    for (node_it = candidates.begin(); node_it != candidates.end(); node_it++) {
        Node *from = *node_it;
        assert(from != nullptr);
		print_ident(ident);
		std::cout << "Select Edge from 0x" << std::hex << from->get_gid() << " to 0x" << cur_node->get_gid() << std::endl;
        ret_path = critical_path_to(ident + 1, from, calculate_deadline(in_edges, from));

        if (ret_path.size() > 0) {
           ret_path.push_back(cur_node);
           return ret_path;
        }
    }
    return ret_path;
}

double CriticalPath::calculate_deadline(edge_map_t in_edges, Node *from)
{
    edge_map_t::iterator it;
    for (it = in_edges.begin(); it != in_edges.end(); it++) {
       if (it->first->from == from)
            return it->first->e_from->get_abstime();
    }
    //should not come here
    assert(false);
    return 0;
}

void CriticalPath::save_path_to_file(std::string filepath)
{
	//write data to log
    std::ofstream output(filepath);
    std::vector<Node *>::iterator pit;
    output << "Critical path size = " << path.size() << std::endl;
    for (pit = path.begin(); pit != path.end(); pit++) {
        Group *cur_group = (*pit)->get_group();
        output << std::hex << " \t-> 0x" << cur_group->get_group_id();
        output << "\t" << cur_group->get_procname();
        output << "\t" << std::fixed << std::setprecision(1);
        output << cur_group->calculate_time_span() << std::endl;
        cur_group->streamout_group(output);
    }
    output << std::endl;
    output.close();
}

void CriticalPath::save_path_to_file(std::string filepath, std::vector<Node *> &path)
{
	//write data to log
	std::ofstream output(filepath, std::ios::app);
	
    std::vector<Node *>::iterator pit;
	output << "Path from 0x" << std::hex << path.front() \
			<< " to 0x" << std::hex << path.back() << std::endl;
    output << "Critical path size = " << path.size() << std::endl;
    for (pit = path.begin(); pit != path.end(); pit++) {
        Group *cur_group = (*pit)->get_group();
        output << std::hex << " \t-> 0x" << cur_group->get_group_id();
        output << "\t" << cur_group->get_procname();
        output << "\t" << std::fixed << std::setprecision(1);
        output << cur_group->calculate_time_span() << std::endl;
    }
    output << std::endl;
    output.close();
}
