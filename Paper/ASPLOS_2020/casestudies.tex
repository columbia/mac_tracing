\section{Case Studies}\label{sec:casestudy}

In this section, we demonstrate how \xxx helps to diagnose \nbug spinning-cursor
cases in \napps popular applications. Table~\ref{table:bugs-desc} describes
these spinning-cursor cases, which are detailed in the sections that follow. We
compared \xxx with traditional causal tracing methods on edges and vertices
\xxx mitigated. We studied the ratios of over-connection filtered with message
peers heuristics, and incognito under-connections disclosed by data flags and
wait heuristics. Even with our technique, the filtered graph remains too imprecise
for automatic causal tracing. Fortunately, user interactions compensates
the inaccuracy in causal path slicing, while not overwhelming the diagnosis
process.

Our results in Table~\ref{table:results} show up to 3 user queries usually
suffice to find root cause path precisely. Although complex applications like
7-MSWord requires 22 queries, many repeated patterns can be easily identified
by users, as discussed below. The paths exclude much noise, and are shorter
and easier to inspect, compared to the traditional slicing automatically with
heuristics.

%% consider adding comparison to prior approaches
%% Our techniques effectively removed false and added missing edges in the
%% event graph.  Even with our techniques, the resultant graph remain too
%% imprecise for traditional causal tracing, but, fortunately, an average
%% of XXX user queries suffice to locate the root causes precisely.
\input{spinningcursor}

\input{bugdesc}

%Bug 0-Apple is ...... The spinning cursor is created when the main thread
%stops responding to events for two seconds. Every application has an
%NSEvent thread, which coordinates with WindowsServer to display a spinning
%cursor when necessary. Two data flags ``\vv{is\_mainthread\_spinning}'' and
%``\vv{dispatch\_to\_mainthread}'' are involved.
%Start a new paragraph "TableXXX shows the results. [Here we should show the big
%table, and talk about the high-level bits.]"

\begin{table*}[ht]
\footnotesize
\centering
  \begin{tabularx}{\textwidth}{l|ccccccc}
 	   & portion of & portion of & \# of& \# of & \multicolumn{2}{c}{size of baseline/spinning path}& interactive slicing\\
       & connections & connections added  & user provided & user  & \multicolumn{2}{c}{with}  & over \\
Bug ID & filtered out & by heuristics & data flag & interaction & interactive slicing & automatic slicing &  auto slicing\\
\hline
\hline
1-SystemPref & 0.0056 & 0.0248 & 2 & 1 & 2 & 30 & 0.07\\
2-SequelPro & 0.0049 & 0.0035 & 0 & 2 & 5 & 264 & 0.02\\
3-TeXStudio & 0.0243 & 0.0058 & 0 & 3 & 6 & 44  & 0.14\\
4-Installer & 0.0439 & 0.0283 & 0 & 2 & 6 & 36  & 0.17\\
5-Notes & 0.0297 & 0.1153 & 0 & 2 & 10 & 42 & 0.24\\
6-TextEdit & 0.0797 & 0.0072 & 0 & 3 & 21 & 21 & 1.00\\
7-MSWord & 0.0672 & 0.0104 & 0 & 22 & 67 & 136 & 0.49\\
8-SlText & 0.0407 & 0.0092 & 0 & 1 & 3 & 3 & 1.00\\
9-TextMate & 0.0215 & 0.0218 & 0 & 0 & 3 & 3 & 1.00\\
10-CotEditor & 0.0481 & 0.0532 & 0 & 1 & 4 & 6 & 0.67\\

\hline
  \end{tabularx}

  \parbox{\textwidth}
  {\caption{Graph Comparison} 
	  {1.\xxx filters out connections by dividing a batch processing vertex into
		  vertices, and adds connections as edges for data flag or heuristic. The portion
		  changed is small. 2.\xxx only requires a few user interactions, but it is
		  critical to reduce the path, so as to reduce user's inspecting efforts in
		  diagnosis. 3.The last column shows the ratio of path size with user interactions
	  over the automatic slicing.}
  \label{table:results}
  }

\end{table*}
%Last paragraph:
%In the remaining of this section, we present the case studies by category in (\S\ref{XXX}). 
\input{longrunning_case.tex}
\input{longwait_and_repeatedyield_case.tex}
