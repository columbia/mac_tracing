\section{Implementation}\label{sec:implementation}
We now discuss how we collect tracing events from both kernel and libraries.

\subsection{Event Tracing}
Current macOS systems support a system-wide tracing infrastructure built by
Apple~\cite{linktotracetool}. By default, the infrastructure temporarily stores
events in memory and flushes them to screen or disk when an internal buffer is
filled. We extended this infrastructure to support larger-scale tests and avoid
filling up the disk with a file-backed ring buffer. Each log file is 2GB by
default, which users can override. This size corresponds corresponds to
approximately 19 million events (about 5 minutes with normal operations).

The default tracing points in macOS provide too limited information to enact
causal tracing. As a result, we instrument both the
kernel~\cite{linkofxnusourcecode} (at the source level) and key libraries (at
the binary level), to gather more tracing data. We instrumented the kernel with
1,193 lines of code, and binary-instrumented the following libraries:
\vv{libsystem\_kernel.dylib}, \vv{libdispatch.dylib}, \vv{libpthread.dylib},
\vv{CoreFoundation}, \vv{CoreGraphics}, \vv{HIToolbox}, \vv{AppKit} and
\vv{QuartzCore} in XXX different places. 

%%Next subsection describes our binary instrumentation tool


\subsection{Instrumentation}

Most libraries as well as many of the applications used day-to-day are
closed-source in macOS. To add tracing points to such code, techniques such as
library preloading to override individual functions are not applicable on macOS,
as libraries use two-level executable namespace~\cite{twolayernamespace}. Hence,
we implemented a binary instrumentation mechanism that allows developers to add
tracing at any location in a binary image.

Like Detour~\cite{hunt1999detours}, we use static analysis to decide which
instrumentation to perform, and then enact this instrumentation at runtime.
Firstly, the user finds a location of interest in the image related to a
specific event by searching a sequence of instructions. Then the user replaces a
call instruction to invoke a trampoline target function, in which we overwrite
the victimized instructions and produce tracing data with API from Apple.
All of the trampoline functions are grouped into a new image, as well as an
initialization function which carries out the drop-in replacement. Then command
tools from \xxx helps to configure the image with the following steps: (1)
re-export all symbols from the original image so that the original code can be
called like an shared library; (2) rename the original image, and use original
name for the new one to ensure the modifications are properly loaded; (3) invoke
the initialization function externally through \texttt{dispatch\_once} during
the loading.

%%One potential issue is that we use 5-byte call instructions with 32-bit
%%displacements to jump from the original library to our new one.  This design
%%requires that the libraries be loaded within +/- 2GB of each other in the
%%64-bit process address space.  However, since we list each original library as
%%a dependency of our new libraries, the system loader will map each new and
%%original library in sequence.  In practice, the libraries ended up very close
%%to one another and we did not see the need to implement a more general
%%long-jump mechanism.

%\subsection{User Interaction}\label{subsec:tcp}
%\para{Tracing Custom Primitives}

\subsection{Tracing Data flags} \label{subsec:tcp}
%%XXX give a simple command line example of how a user can ask \xxx to trace a
%%data flag
%%XXX say what we do in watch point exception handler (record instruction so
%%can determine read or write, and reg values)
As described in (\S\ref{subsec:userinteraction}), under-connection due
to the missing data dependency requires users' interaction. \xxx
provides a command line tool which sets the watch point registers to record
\dataflagwrite and \dataflagread events in ad-hoc manner. This is one
way users can easily collect the tracing events, and the more tech-savvy users
can also instrument the binary. The tool takes the process id, path to image
where the variable is defined and the symbol of the variable as input. We
show the simple example how a user ask \xxx to trace \vv{\_gOutMsgPending} in the
following command.

\begin{lstlisting}
./bp_watch pidofWindowServer Path/to/CoreGraphics\
	_gOutMsgPending
\end{lstlisting}

\xxx hooks the watch point break handler in CoreFoundation to make sure that it is
loaded correctly into the address space of our target application. The handler
invokes the event tracing API from Apple to record the value of the data flag
and the operation type: read or write.

\subsection{Find baseline scenario}

\xxx finds a baseline scenario to figure out the missing wake-up edge in
spinning case. It begins from identifying a vertex which shares
the same high level semantics of the \spinningnode but bares
different execution results. 


\xxx identifies the high level semantics of vertices with semantical events
in vertices, including system calls, call stacks, user actions. \xxx compares
their sequential order and the event attributes unchanged in runtime. For
example, \xxx compares the system call number and symbols in callstack.
To improve the accuracy, \xxx also checks the events for forming edges in
graph, including messages, dipatch queue operations, runloop operations,
\dataflagread and \dataflagwrite, as they might reveals the low level behaviors
of developer intent. \xxx compares their peers. Depending on the report detail
of \spinningnode, user can request \xxx to compare proceeding vertices to
improve accuracy of finding the same semantic vertices.

By default, \xxx compares the execution time and the wait results to manifest
different execution results. If multiple \similarnode are identified,
\xxx usually asks users for a comfirmation, or choose the most recent one
hueristicstically.

\subsection{Capturing Instructions for Diagnosis}

Users may need to gather more information, such as instructions executed to
verify and come up a binary patch. \xxx integrates with lldb to capture
instructions executed and add them to the nodes in the event graph. It generates
the debugging scripts with the light weight call stack from the \rootcausenodes.

The debugging scripts go through the instructions of apps and frameworks step
by step to capture the parameters tainted by user inputs. At each beginning of
a function call, the script records a full call stack for it. Considering the
overhead and usefulness, it steps over and only records the return value of APIs
from libraries with a filename extension \vv{.dylib}.

The supplementary information are subject to the users review to pinpoint the
root cause of spinning beachball on macOS.

