\subsubsection{Long Wait and Repeated Yield}

In this section, we discuss the cases where the \spinningnode is blocking on
wait event or yielding loop, corresponding to LongWait and RepeatedYield.
These cases are mostly can be verified by themselve, as the root causes are
manifested by comparing to normal scenarios.

\paragraph{2-SystemPref}

\vv{System Preferences} provides a central location in macOS to customize system
settings, \eg additional monitors configuration.
\vv{DisableMonitor}~\cite{disablemonitor} provides more functionality, \eg
enable/disable monitors online. We caught the spinning cursor while we disable
an external monitor and rearrange windows in \vv{Display} panel.

The log collected by \xxx contains 2 cases: 1) a baseline scenario where the
displays are rearranged with the enabled external monitor, and 2) a spinning
scenario as we described above. The \spinningnode in the main thread is dominated
by system calls, \vv{mach\_msg} and \vv{thread\_switch}, which falls into the
category of Repeated Yield. We discovered two missing data flags,
``\vv{\_gCGWillReconfigureSeen}'' and ``\vv{\_gCGDidReconfigureSeen}'', which
signify the configuration status and break the thread-yield loop. 
\xxx's diagnosis result reveals that the main thread in \vv{System Preferences} sets
them after receiving specific datagrams from \vv{WindowServer}. Conversely, the
setting of ``\vv{\_gCGDidReconfigureSeen}'' is missing in the spinning case.
The main thread thus repeatedly sent messages to \vv{WindowServer} for datagram.

In conclusion, we discovered that the bug is inherent in the design of the
\vv{CoreGraphics} framework, and would have to be fixed by Apple. We verified this
diagnosis by creating a dynamic binary patch to fix the deadlock. The
patched library makes \vv{DisableMonitor} work correctly, while preserving correct
behavior for other applications.

\paragraph{3-SequelPro}

\vv{Sequel Pro}~\cite{SequelPro} is a fast, easy-to-use Mac database management
application for \vv{MySQL}. It allows user to connect to database with socket or ssh.
We experienced the non-responsiveness of Sequel Pro when it lost network
connection and tried reconnections.

The tracing log contains two cases: 1) a quick network connection during login,
and 2) Sequel Pro lost connection for a while. Although \xxx identified the
\spinningnode and \similarnode with ease, the backward slicing from
\similarnode encountered multiple incoming edges, including one from a kernel
thread, where batching processing from different applications happens.
Interaction is helpful and reduces the noise in the path.  Diagnosis on the
\spinningnode, comparing with the normal causal path, tells that the main thread
is blocking on a kernel thread, which in turn waits for a ssh thread. Thus the
root cause is the blocking for network IO.

\paragraph{4-Installer}

\vv{Installer}~\cite{Installer} is an application that extracts
and installs files out of \vv{.pkg} packages in macOS. When \vv{Installer} pops up a
window for privileged permission during the installation of
\vv{jdk-7u80-macosx-x64}, moving the cursor out of the popup window triggers a
spinning cursor.

\xxx successfully records the baseline scenario with our operations. We first
type in password in the pop-up window and then click the back button to
reproduce the spinning case described above.  Examining the \spinningnode and
its \similarnode, \xxx reveals the daemon \vv{authd} blocks on semaphore while
the main thread is waiting for \vv{authd}. Further checking on \vv{authd}, \xxx
finds out \vv{SecurityAgent} processes user input and wakes up \vv{authd} in
baseline scenario. In conclusion, moving the mouse out of the authentication
window causes the missing edge from \vv{SecurityAgent} to \vv{authd}, which in
turn blocks \vv{Installer}.

We also discovered a communication pattern in \vv{Installer} underpinning the
crucial of interactive debugging. It involves four vertices in four threads,
vertex $Vertex_{main}$ in the main thread, and $Vertex_1$ to $Vertex_3$ in
three worker threads. First, the main thread wakes up three worker threads.
Then one worker thread is scheduled to run. At its end, another worker thread,
which waits on mutex lock, is woken in $Vertex_2$, which in turn wakes up the
next worker thread in $Vertex_3$. While \xxx is slicing backward, $Vertex_3$
has two incoming edges: one is from $Vertex_{main}$, and the other one is from
$Vertex_2$. Since users can peek the edges before making decision, they are
likely to figure out that the three worker threads contend with mutex lock, and
all of them are successors of $Vertex_{main}$.

