\subsection{Methodology} \label{sec:methodology}

%%In this section, we first describe how the performance issues are selected for
%%study. Then we compare \xxx to its closest prior system, and describe how we
%%evaluate the manual efforts needed in diagnosis.

Prior work relies on the request graph per transaction to identify bottleneck
and speculate possible causes. Panappticon for Android is one and closest to
ours in desgin. Their traced events and causality are in a subset of ours.
It is common to see multiple user inputs are connected into a Panappticon's
request graph, but the programming paradigm caused the over-connection is hard
to reveal due to the closed-source Cocoa framework in macOS. We therefore carry
out the inaccuracy study in ~\S\ref{sec:toystudy} with a non-GUI toy program to
demonstrate the inherent inaccuracy of causal tracing.

For real-world case study, we collect performance issues of popular
applications, because they likely represent the bugs attractive to tech-savvy
users. Among the 26 bugs from the github reports, we reproduced 3 of them
successfully. Others are failed either due to the version capacity in ElCapitan
or insufficient information in the bug report. 8 performance issues are
collected from the daily use applications in the auther's laptop. As a result,
we study 11 reproducible cases. 

%Also explain what metrics/outcomes we look for. "whether these tools enable a
%developer to identify root cause of a given performance issues" or "quantify the
%manual effort needed to ..."

Now we describe how we measure the effects of heuristics which \xxx uses to
mitigate the graph inaccuracy, and manual efforts required in the diagnosis. We
first enable tracing component and reproduce the performance isssues in macOS.
When \xxx constructs event graph with the trace log, we measure the number of
over-connection and under-connection mitigated by heuristics. After this step, a
vertex in the graph can still have multiple incoming edges or weak edge. We then
run \xxx diagnosis algorithm with a human in the loop, and count the times when
multiple incoming edges or weak edges are encountered. Users can query the event
graph for assistance or make decisions with domain knowledge. In the worst case
that users make a wrong decision, before reaching the end of path slicing, \xxx
allows them to relocate the path to a particular vertex.

%Specifically, the number presented in the following section reflects our
%experience of debugging. It does not include the situation of relocating vertex
%in path slicing, which we have not encountered in our case studies.
