\subsection{Comparison to Other Causal Tracing Tools} \label{sec:toystudy}

We compared \xxx to two closely related tools, AppInsight and Panappticon.
For Panappticon, we reimplemented its algorithm inside \xxx.  For
AppInsight, since it traces only a single process, we analyzed how its
algorithm would have worked without reimplementation.

\begin{table}[ht]
\footnotesize
\centering
  \begin{tabularx}{\columnwidth}{l|XXX}
  \hline
Bug ID & Panappticon & AppInsight & \xxx\\
\hline
\hline
2-SystemPref & \mycross(data flags) & \mycross(WindowServer) & \mycheck (2 data flags) \\
3-SequelPro & \mycross(batching in kernel task) & \mycross(sshd) & \mycheck(2 ME)*\\
4-Installer & \mycross(batching in worker thread) & \mycross(SecurityAgent, authd)& \mycheck(1 WE, 1 ME)*\\
5-TeXStudio & \mycross(appkit event, timer, batching in WindowServer) & \mycross(fseventd) & \mycheck(3 ME)*\\
\hline
  \end{tabularx}
  \caption{Compare Effectiveness of Causal Tracing System. *WE stands for user
	interaction on Weak Edges, *ME stands for user interaction on Multi-incoming
	Edges in \xxx.}
  \label{table:comps}
  \vspace{-0.5cm}
\end{table}

We used two sets of applications for this comparison.  First, we chose the
harder cases from the \nbug real-world spinning cursors.  It turned out
that neither AppInsight nor Panappticon was able to diagnose any of these
spinning cursors. Table~\ref{table:comps} shows the reasons.  Panappticon
handles only a limited set of programming idioms, missing at least data
flags, batching, and timers.  AppInsight was not able to capture beyond
single process.  In contrast, with a small amount of help from users, \xxx
successfully diagnosed all issues.

Second, since these real-world applications are quite complex, we used
another set of three toy applications to make it less challenging to
AppInsight and Panappticon. Table~\ref{table:microbenchmarks} shows the
results.

In the \vv{AppList} case, we selected \vv{Sequel Pro} from the list of running
applications, and clicked the \vv{Hide} button to minimize it. Within \xxx's
graph, the ground truth sequence of interprocess communication exists: the
sequence is \vv{WindowServer} user events $\rightarrow$ \vv{appleeventsd}
$\rightarrow$ \vv{launchserviced} $\rightarrow$ \vv{Sequel Pro}. The graph
has 59 vertices which include multiple incoming edges that a user might need to
distinguish between. Panappticon's graph is a strictly larger superset; it is
much harder to find the ground truth path because spurious edges are included
in far more than 59 vertices, as is information from unrelated processes.
It contains 20 processes, at least 7 of which are unrelated. 4 of them are
included because \vv{WindowServer} batches event processing as shown in
Figure~\ref{fig:batchingineventprocessing}; 3 of them are from kernel task's
batching in timer processing. In addition, 4 UI events (mouse click, mouse move,
system defined, and mouse exit event) passed to \vv{AppList} are present in the
same graph because of batching in runloop blocks~\cite{runloop}. Panappticon
cannot split the batched operations without tracking the flags mentioned earlier
in Figure ~\ref{fig:casharedflag}, A third causal tracing system, AppInsight, is
capable of tracking the boundaries of event handlers; however, we did not run it
because it only tracks events within one application, and would miss events in
all daemons as well as in \vv{Sequel Pro} itself. 

Panappticon and AppInsight failed similarly for \vv{AbSearch} and
\vv{AnimatedSlider} cases. In the \vv{AbSearch} case, we search people with
first name "Smith" from the \vv{Contacts}. The event handler constructs a
search element with the input information, and gets an array of people as
search result. The \xxx's graph includes the user input, communications between
\vv{AbSearch} and \vv{tccd}, and the display update. However, Panappticon fails
to extract a complete user transaction graph. It misses the searching element
construction due to lack of data flag tracing. On the other hand, AppInsight
does not trace the activity in \vv{tccd}. \vv{AnimatedSlider} takes a percentage
number in its text field as input, and sends message to the \vv{SystemUIServer}
to begin animation after we press return key. AppInsight is not able to capture
such activity. Panappticon's graph contains 18 UI events because of the batching
in runloop, and 5 unrelated applications from \vv{WindowServer}'s batch
processing. On the contrary, the event graph generated by \xxx is easier to find
the ground truth with a few interaction, in that only 8 vertices with multiple
incoming edges are found in \xxx's event graph.


%% In each microbenchmark, we turn on the
%% appropriate causal tracing system, launch the application we are testing, \eg
%% \vv{AppList}, and perform our specified GUI interation. We then terminate the
%% causal tracing system, and ask it to construct a request graph at the moment we
%% clicked on a GUI element. We search for a path through the request graph from
%% the GUI action to a display update, and ensure that the path matches the ground
%% truth (obtained through manual investigation).

%In this study, we chose \vv{Sequel Pro} from the list
%of running applications, and clicked the \vv{Hide}. To find the ground truth
%for the transaction, we manually check the tracing log with extra
%instrumentation in event handler. \vv{AppList} fetches user input events from
%\vv{WindowServer}. The user input event handler invokes \vv{appleeventsd} and
%\vv{launchserviced}, which communicate with the chosen app \vv{Sequel Pro}.
%\vv{Sequel Pro} hides itself and \vv{AppList} updates main window. During the
%process, \vv{AppList} invokes daemons like \vv{cfprefsd}, \vv{distnoted},
%\vv{fseventsd}, \vv{syslogd}, \vv{systemstatsd} to communicate with system.

%The graph generated with Panappticon contains more information than
%what we identified. It has 20 processes involved. We identify at least
%7 of them are unrelated to the app. 4 of them are connected because
%of the \vv{WindowServer}'s batching in event processing as shown in
%Figure~\ref{fig:batchingineventprocessing}, and 3 of them are from kernel task's
%batching in timer processing. In addition, 4 UI events(mouse click, mouse move,
%system defined, and mouse exit event) passed to \vv{AppList} are present in the
%same graph because of batching in runloop blocks~\cite{runloop}. All the UI
%updates are batching in a callout function from the runloop. Without tracking
%the flags in Figure ~\ref{fig:casharedflag}, Panappticon can not seperate them.

%Without the Apple developers' efforts, \xxx's binary instrumentation on runloop
%is also not enough to identify all under- and over-connections, therefore our
%event graph exposes 59 vertices with multiple incoming edges.
%

\begin{table}[tb]
	\footnotesize
	\centering
	\begin{tabularx}{\columnwidth}{l|l|l}
		\hline
		Microbenchmark & Panappticon & \xxx \\
		\hline\hline
		\begin{tabular}{@{}l@{}}
			AppList\\
			(minimize a\\
			running app)
		\end{tabular}
		& 
		\begin{tabular}{@{}l@{}}
			have 7 unrelated \\
			apps due missing\\
			boundaries of batching.
		\end{tabular}
		& 
		\begin{tabular}{@{}l@{}}
			contain 59 vertices\\
			with multiple\\
			incoming edges.
		\end{tabular}
		\\
		\hline
		\begin{tabular}{@{}l@{}}
			AbSearch\\
			(search Contacts\\
			with first name\\
			Smith )
		\end{tabular}
		 & 
		\begin{tabular}{@{}l@{}}
			miss the searching\\
			element construction\\
			in handler for lack of\\
			tracing data flag.
		\end{tabular}
		 &
		\begin{tabular}{@{}l@{}}
			contain 72 vertices\\
			with multiple\\
			incoming edges.
		\end{tabular}
		\\
		\hline

		\begin{tabular}{@{}l@{}}
		AnimatedSlider\\
		(move slider\\
		with percentage\\
		in extolled)
		\end{tabular}
            &
		\begin{tabular}{@{}l@{}}
		connect 5 unrelated apps\\
		for lack of boundaries \\
		on batching.
		\end{tabular}
            &
		\begin{tabular}{@{}l@{}}
		contain 9 vertices with\\
		multiple incoming\\
		edges.
		\end{tabular}
		\\
\hline
  \end{tabularx}
\caption{Inaccuray of request graph for microbenchmarks.}
\label{table:microbenchmarks}
\end{table}
