\subsection{Microbenchmark} \label{sec:toystudy}

In the section, we demonstrate the inaccuracy of request graph extracted with
prior causal tracing system. We first describe the study carried out on the
application from Apple's sample code \vv{AppList}~\cite{applist}, and then we
lists microbenchmarks in Table~\ref{table:microbenchmarks}.

The main window of \vv{AppList} shows all running applications. \vv{Hide},
\vv{Unhide}, and \vv{Terminate} buttons are beside the window for users to
manipulate a chosen app.  In the study, we chose \vv{Sequel Pro} from the list
of running applications, and clicked the \vv{Hide}. To find the ground truth
for the transaction, we manually check the tracing log with extra
instrumentation in event handler. \vv{AppList} feteches user input events from
\vv{WindowServer}. The user input event handler invokes \vv{appleeventsd} and
\vv{launchserviced}, which communicate with the chosen app \vv{Sequel Pro}.
\vv{Sequel Pro} hides itself and \vv{AppList} updates main window. During the
process, \vv{AppList} invokes daemons like \vv{cfprefsd}, \vv{distnoted},
\vv{fseventsd}, \vv{syslogd}, \vv{systemstatsd} to communicate with system.

The graph generated with Panappticon contains more information than
what we identified. It has 20 processes involved. We identify at least
7 of them are unrelated to the app. 4 of them are connected because
of the \vv{WindowServer}'s batching in event processing as shown in
Figure~\ref{fig:batchingineventprocessing}, and 3 of them are from kernel task's
batching in timer processing. In addition, 4 UI events(mouse click, mouse move,
system defined, and mouse exit event) passed to \vv{AppList} are present in the
same graph because of batching in runloop blocks~\cite{runloop}. All the UI
updates are batching in a callout function from the runloop. Without tracking
the flags in Figure ~\ref{fig:casharedflag}, Panappticon can not seperate them.

AppInsight is effective in tracking the boundary of the event handler, however,
it does not track the execution boundaries in daemons. Thus, it can not track
the activities in \vv{appleeventsd}, \vv{launchserviced} and \vv{Sequel Pro}.

Without the Apple developers' efforts, \xxx's binary instrumentation on runloop
is also not enough to identify all under- and over-connections, therefore our
event graph exposes 59 vertices with multiple incoming edges.

\begin{table}[tb]
\footnotesize
\centering
  \begin{tabularx}{\columnwidth}{l|X}
\hline
Microbenchmark & Description\\
\hline\hline
AppList & AppList manipulates running apps in system.\\
        & \mycross Panappticon connects 7 unrelated apps due to lack of boundaries on batching.\\
        & \mycross \xxx event graph contains 59 vertices with multi-incoming edges.\\
\hline
AbSearch & AbSearch searches Contacts with first name.\\
         & \mycross Panappticon misses connections to the searching\\
         & element constuction due to lack of tracing data flag.\\
         & \mycross \xxx event graph contains 72 vertices with multi-incoming edges.\\
\hline
AnimationSlider & AnimationSlider moves slide bar with input percentage in textfield.\\
            & \mycross Panappticon connects 5 unrelated apps due to lack of boundaries on batching.\\
            & \mycross \xxx event graph contains 9 vertices with multi-incoming edges.\\
\hline
  \end{tabularx}
\caption{Inaccuray of request graph for microbenchmarks.}
\label{table:microbenchmarks}
\end{table}
