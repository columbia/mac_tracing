\section{Patterns}
\label{sec:patterns}

We encountered several instances of runtime event dependencies between thread
contexts. We present several generalizable cases below.

\para{P1: Signal handling}
Sometimes, a signal handler happens to run within a thread's context, for
example, a timer interrupt. We identify the start and end of the
signal-handling code to splice it away from the containing context, since it is
usually unrelated.

{\footnotesize \begin{verbatim}
thread 1      thread 2

sleep(50);    running
              process receives timer interrupt();
                signal_handler
                  make_runnable(thread_1);
\end{verbatim}
}

\para{P2: Kernel takes over context}
As part of a thread context switch, an execution context may enter kernel
space. The code will enter kernel scheduling and wake up another
\texttt{kernel\_task} thread.

{\footnotesize \begin{verbatim}
thread_invoke(self, new_thread) // thread switch, kernel space
  sched_timehsare_consider_maintance()
    wake up another kernel_task thread
\end{verbatim}
}

To detect this case, we filter wakeups from the kernel timer, interrupt
handler, or kernel shared memory maintenance. Such cases represent spurious
dependencies. However, sometimes when a worker thread wakes up another worker
thread, this can represent a true dependency. The distinguishing feature is
whether a synchronization primitive (shared memory) is used.

\para{P3: Batching in event processing}
The WindowServer MacOS system daemon contains an event loop which waits on Mach
messages. Conceptually, it processes a series of independent events from
different processes. However, to save on kernel boundary crossings, it uses a
single system call to receive data and send data for an unrelated event. This
batch processing artificially makes many events appear dependent, and we split
the execution segments to maintain the independence of the events.

{\footnotesize \begin{verbatim}
  while() {
    message = receive and send Mach msg(pending_reply) // reduces
kernel crossing presumably
    process message
    if (message needs reply)
      pending_reply = reply // only keeps one pending message
  }
\end{verbatim}
}

\para{P4: CoreAnimation shared memory}
A worker thread can set a global variable inside a CoreAanimation objects
whenever the object needs to be repainted. The main thread iterates over all
animation objects and reads this flag, rendering any such object. This creates
a dependency between the main thread and the worker, but these dependencies are
extremely common and do not communicate much information.

{\footnotesize \begin{verbatim}
  worker thread that needs to update UI
  ObjCoreAnimation->need_display = 1

  main thread:
  traverse all CoreAnimationobjects
  if obj->need_display == 1
    render(obj)
\end{verbatim}
}

\para{P5: Spinning beach ball shared flag}
Whenever the system determines that the main thread has hung for a certain
period, and the spinning beach ball should be displayed, a shared memory flag
is set. Access to this flag is controlled via a lock, i.e. the lock is used for
mutual exclusion, and does not imply a happens before relationship.

{\footnotesize \begin{verbatim}
  NSEvent thread                      main thread

while()
  NSArray[produced++] = event
  event_dispatched = 1
  if main_thread_spinning != 1n
    register_timer(2 seconds, callback_closure}
                                    while()
                                      event = NSArray[consumed++];
      process event;
    callback_closure
      if event_dispatched == 1
        main_thread_spinning = 1
                                      if main_thread_spinning == 1
      main_thread_spinning = 0;
              event_dispatched = 0
\end{verbatim}
}

\para{P6: Dispatch message batching}
The message dispatch service dequeues messages from many processes and staggers
processing of the messages. This creates false dependencies between each
message in the dispatch queue.
{\footnotesize \begin{verbatim}
fontd

worker thread

dispatch_queue.enqueue(
   your code
)
  // create block function


block = dispatch_equeue.dequeue()
block
  dispatch_mig_service()
    while(){
      receive mach message
      process
      optional reply if needed
    }
\end{verbatim}
}

\para{P7: Mach message mismatch}
In most systems, two threads are used to communicate messages.
In the Mach message system, four threads are involved.
Use recv port to connect messages.

{\footnotesize \begin{verbatim}
thread 1,proc1      thread 2,proc2    thread 3,proc2    thread 4, proc 1
send mach msg1
                  recv mach msg1
      send mach msg2
                                      recv msg2
              send msg3
                            recv msg3 // reply
 xpc (higher than mach msg
 scim to chrome

 scrim thread   t2          chrome worker thread            chrome main thread
  send (msg has recv port)
                           dispatch_mach_msg_recv
                                        ?

xpc_connection_and_send_msg (msg has scim recv port)
               recv
\end{verbatim}
}

\para{P8: Runloop callbacks}
As is common in event driven programming, many methods can post a callback to a runloop to continue processing at a later time.

{\footnotesize \begin{verbatim}
done by another thread
callout_to_runloop(runloop, source, port, cb) cb installation
log runloop, source, port, cb // runloop, source, port help identify
the right execution of cb() to connect to

   runloop will call cb()
   cb begin: we log runloop, source, port so right match
\end{verbatim}
}

\para{P9: Timers}
Most timers in MacOS are repeat timers, meaning that the timer reregisters itself before finishing.
This creates complex dependencies because timers are invoked asyncronously during interrupts.


{\footnotesize \begin{verbatim}
\
timer_create
     |       \ (may or may not fire)
     |        timer_expire
     |
timer_cancel
     |
timer_create
     |
timer_create  // repeat timer?
            \timer_expire

\end{verbatim}
}
