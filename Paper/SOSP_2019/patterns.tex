\section{Dependency Semantics}
\subsection{Tracing Events}
The log that \xxx collects consits of a squence of tracing events, falling into three categories:
semantics tracing events, dependency tracing events and boundary tracing events.
Semanctics events include system calls, backtraces and instruction logs.
Boundary events are recorded within a single thread where we may eventually place an execution segment boundary.
Dependency events are recorded whenever one thread comunnicates with another,such that we will eventually create causual links---for example, a thread calls \textit{mach\_msg\_send} and delivers message to anther thread which calls \textit{mach\_msg\_receive}. These two dependency events will eventually be used to create a link in the graph.


\subsection{Dependency Patterns}
\label{sec:patterns}

We encountered several instances of runtime event dependencies between thread
contexts. We present several generalizable cases below.

\para{P1: Signal handling}
Sometimes, a signal handler happens to run within a thread's context, for
example, a timer interrupt. We identify the start and end of the
signal-handling code to splice it away from the containing context, since it is
usually unrelated.

{\footnotesize \begin{verbatim}
kernel_task       Notes
wait(io_work)
		  state64()
	          intterupt()
                    state = save_contex  
		    lapic_interrupt(intr, state)
	          wait(lock_mutex)
timer_callout
wake_up(coreduetd)
\end{verbatim}
}

\para{P2: Kernel takes over context}
As part of a thread context switch, an execution context may enter kernel
space. The code will enter kernel scheduling and wake up another
\texttt{kernel\_task} thread.

{\footnotesize \begin{verbatim}
thread_invoke(self, new_thread, reason) // thread switch, kernel space
  sched_timehsare_consider_maintance()
    thread_wakeup((event_t)sched_timeshare_miantenance_continue);
  ast_context(new_thread);
\end{verbatim}
}

To detect this case, we filter wakeups from the kernel timer, interrupt
handler, or kernel shared memory maintenance. Such cases represent spurious
dependencies. However, sometimes when a worker thread wakes up another worker
thread, this can represent a true dependency. The distinguishing feature is
whether a synchronization primitive (shared memory) is used.

\para{P3: Batching in event processing}
The WindowServer MacOS system daemon contains an event loop which waits on Mach
messages. Conceptually, it processes a series of independent events from
different processes. However, to save on kernel boundary crossings, it uses a
single system call to receive data and send data for an unrelated event. This
batch processing artificially makes many events appear dependent, and we split
the execution segments to maintain the independence of the events.
%// reduces kernel crossing presumably
%// only keeps one pending message
{\footnotesize \begin{verbatim}
  while() {
    CGXPostReplyMessage(msg)
      push_out_message(pending_reply)
      pending_reply = msg
    CGXRunOneServicePass()
      if(_gOutMessagePending)
	mach_msg_overwrite(option = send|receive, pending_reply)
      else
        mach_msg(option = receive)
      processing
  }
\end{verbatim}
}

\para{P4: CoreAnimation shared memory}
A worker thread can set a global variable inside a CoreAanimation objects
whenever the object needs to be repainted. The main thread iterates over all
animation objects and reads this flag, rendering any such object. This creates
a dependency between the main thread and the worker, but these dependencies are
extremely common and do not communicate much information.

{\footnotesize \begin{verbatim}
  worker thread that needs to update UI:
  ObjCoreAnimation->need_display = 1

  main thread:
  traverse all CoreAnimationobjects
  if obj->need_display == 1
    render(obj)
\end{verbatim}
}

\para{P5: Spinning beach ball shared flag}
Whenever the system determines that the main thread has hung for a certain
period, and the spinning beach ball should be displayed, a shared memory flag
is set. Access to this flag is controlled via a lock, i.e. the lock is used for
mutual exclusion, and does not imply a happens before relationship.

{\footnotesize \begin{verbatim}
  NSEvent thread                      main thread

while()
  NSArray[produced++] = event
  event_dispatched = 1
  if main_thread_spinning != 1n
    register_timer(2 seconds, callback_closure}
                                    while()
                                      event = NSArray[consumed++];
      process event;
    callback_closure
      if event_dispatched == 1
        main_thread_spinning = 1
                                      if main_thread_spinning == 1
      main_thread_spinning = 0;
              event_dispatched = 0
\end{verbatim}
}

\para{P6: Dispatch message batching}
The message dispatch service dequeues messages from many processes and staggers
processing of the messages. This creates false dependencies between each
message in the dispatch queue.
{\footnotesize \begin{verbatim}
fontd

worker thread

dispatch_queue.enqueue(
   your code
)
  // create block function


block = dispatch_equeue.dequeue()
block
  dispatch_mig_service()
    while(){
      receive mach message
      process
      optional reply if needed
    }
\end{verbatim}
}

\para{P7: Mach message mismatch}
In most systems, two threads are used to communicate messages.
In the Mach message system, four threads are involved.
Use recv port to connect messages.

{\footnotesize \begin{verbatim}
SCIM calls XPC_connection_send_msg
t1_scim       t2_chromium        t3_chormium        t4_scim
mach_msg_send(remote_port.reply_port)
             dispatch_mach_msg_receive(remote_port, reply_port)
                                  mach_msg_send(reply_port)
                                                    mach_msg_receive(reply_port)
\end{verbatim}
}

\para{P8: Runloop callbacks}
As is common in event driven programming, many methods can post a callback to a runloop to continue processing at a later time.

{\footnotesize \begin{verbatim}
done by another thread
callout_to_runloop(runloop, source, port, cb) cb installation

log runloop, source, port, cb // runloop, source, port help identify
the right execution of cb() to connect to
   runloop will call cb()
   cb begin: we log runloop, source, port so right match
\end{verbatim}
}

\para{P9: Timers}
Most timers in MacOS are repeat timers, meaning that the timer reregisters itself before finishing.
This creates complex dependencies because timers are invoked asyncronously during interrupts.

{\footnotesize \begin{verbatim}
\
timer_create
     |       \ (may or may not fire)
     |        timer_expire
     |
timer_cancel
     |
timer_create
     |
timer_create  // repeat timer?
            \timer_expire

\end{verbatim}
}
