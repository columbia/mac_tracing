\section{Introduction} \label{sec:intro}
%why we need the tool
%Challenge of debug with current tools
%Difference btw our tool and Magpie, AppInsight.etc
%only lldb: directly apply to the whole execution is too slow
%	 infeasible to run 24X7 to capture the bug log
%only depandancy graph:
%	false positive: timeout(long waiting thread is waken up by timeout, the waker is not the root cause)
%	false negtive: bug can be caused by some missing execution, which would only appear in normal execution
%

%How to conqour the challenges
%trace sysmtem wide, can be added in library and system
%get the relationships of threads from the log
%compare spin and normal case to narrow down the range in log
%apply lldb on a small range of code to unveil root cause
%

Deadlocks and livelocks are known to be significant challenges in developing distributed systems.
A great deal of work has gone into formal analysis of call graphs to try to identify deadlocks.
In practice, when faced with code that deadlocks or may deadlock, many developers will simply add timeouts to all code that obtains locks,
converting a show-stopping hang into a program that will eventually unfreeze itself.
However, the root cause of the cyclic dependency may go unaddressed, leading to significant user-facing delays in applications.

It is difficult for developers to diagnose livelocks with typical tracing or debugging tools (like \texttt{DTrace} or \texttt{lldb})
in user-facing applications for a number of reasons.
First, many function calls happen asynchronously through events or inter-process communication, especially in graphical programs.
This means that control flow travels through the kernel, and the root cause can be far away from an observed hang.
Many processes and threads may be involved, and it is unclear which ones to target.
Secondly, there is a vast number of events being triggered constantly, and
sifting through all the innocuous events to find relevant ones is a Herculean task.
Deadlocks that can be deterministically triggered are challenging enough, but
this problem is exacerbated by livelock situations which by their nature involve the execution of a continuous stream of operations.

In this work, we present our system \textit{\sys} which collects detailed tracing information across all processes on a Mac system.
\sys collects relevant userspace and kernelspace events and messages, and automatically correlates them between processes.
We allow trace points to be inserted at arbitrary locations in each process,
allowing a developer to collect additional information as they hone in on the cause of a livelock or deadlock.

One important aspect of analyzing livelocks is that timeouts typically use real wall time,
and any performance overhead incurred by an analysis tool may cause timeouts to expire more quickly,
affecting program behaviour. Our framework incurs minimal overhead of XXX\% in large-scale tests.
We also present two case studies of \sys applied to real-world problems, including a livelock in Google Chrome.
We believe that \sys represents an important step forward in debugging livelocks in user applications.
