\section{Implementation}
We now discuss how we collect tracing events of interest.

\subsection{Tracing Tool}
Tracing infrastructure builtin current MacOS is lightweight event logging technology which collects system-wide information, stores temporarily in memory and flushes to screen or disk when the buffer is full.
To support the 24X7 tracing without exhaust the system resource, we modify it to dump data to a ring buffer in a file.

\subsection{Instumentation}
The libraries, as well as lots of the daily used Apps on MacOS, are closed source.
Adding tracing points to libraries and Frameworks requires the instrumentation of the binary image.
Techniques, such as library preload with trampolines over the targeted functions, do not meet the requirements due to the two-level namespace executables in Mac.
We hence implement the binary instrumentation lib for developers to add tracing points anywhere.

To complete the instrumentation, we need to find the instruction in the event execution path, where the desired attributes are accessible, and the length of the instruction can hold a call instruction.
We call such instruction as a victim instruction.
It will be substituted with the callq instruction on the fly.
The parameter of the callq instruction is a shell function, which we define to simulate the victim instruction and add tracing points of interest.
With the input of the address of victim instruction and its corresponding shell function, our tool will generate a new library.
In the new library, we define an init function, as shown in Figure \ref{fig: pseudo code for init}, to calculate offsets and replace the victim instruction with the shell function.
The replacement only happened once in the memory by calling the init externally with dispatch\_once.

\begin{algorithm}
\captionof{figure}[pseudo code for init]{pseudo code for init}
\begin{algorithmic}[1]
\Require {$VictimFuncs_{1} \dots VictimFuncs_{N}$ $VictimInstOffsets_{1} \dots VictimInstOffsets_{N}$ $ShellFuncPtrs_{1} \dots ShellFuncPtrs_{N}$}
\Procedure{init}{}
\For {$i \gets 1$ to $N$}
\State {$InstrVaddr$ $\gets$ {\textit{virtual addr of} $VictimFuncs_{i}$} + $VictimInstOffsets_{i}$}
\State {$Offset$ $\gets$ $InstrVaddr$ + 5 - $ShellFuncPtrs_{i}$}
\State {$CallqInstr$ $\gets$ \textit{callq} $Offset$}
\State $mprotect(page$ $of$ $InstrVaddr,$ $R|W|E)$
\State $memcpy(InstrVaddr,$ $CallqInstr)$
\State $mprotect(page$ $of$ $InstrVaddr, R|E)$
\EndFor
\EndProcedure
\end{algorithmic}
\label {fig:pseudo code for init}
\end{algorithm}

Finally, the generated library will re-export all the symbols from the original library and replace the original one.
% as shown in Figure\ref{fig: overview of binary instrument}.
%\begin{figure}
%\centering
%\rule{5cm}{5cm}
%\caption {overview of binary instrument}
%\label {fig: overview of binary instrument}
%\end{figure}
Although one of the shortcomings is that only the short distance function call is supported in our implementation, as the new library and the original one are usually loaded close in memory, we do not need to apply techniques to achieve the long jump in instrumentation.
\subsection{Hardware Watchpoint}
For the shared variable of interest, we take advantage of hardware watchpoints.
Tracing points are added in its handler when the variable is accessed.
We hook the handler in the CoreFoundation to make sure that it is loaded correctly in the space of our interested application.
Setting the hardware watchpoint is ad-hoc with a command line tool we built.
Only the process id, the name, and size of the variable, operation type, read, write, execute, the watchpoint register id(from 0 to 3) need to be specified.

\subsection{Incrmental Instrumentaion}
Due to the transparent of programming paradigms designed by the developer, it does not always generate a complete and accurate dependency graph based on the builtin event schema.
The graph should be incrementally improved with new tracing points somehow.
Two steps are required.
\begin{itemize}
        \item Add tracing points
        \item Parse and add event schemas on the link and split process if necessary.
\end {itemize}


%methodology
We built the toolkit upon the currently generated graph to guild the exploration of the over-connections and miss- connections of thread temporally.
We leverage the tracing points of voucher builtin in MacOS.
Vouchers are propagated through the system to record if a process works on behalf of the other process.
We check the over-connections in one execution segment by examing if multiple user applications connect to it but not in the vouchers.
Checking the path of the connection, as well as the call stack provides hints on the graph improvements.
%results
In our experiment, we discovered multiple programming paradigms in the libraries that are not realized before.
WindowServer will compact the request of send and receive in a mach\_msg\_overwrite\_trap system call, although they are on behalf of different userspace applications.
The function dispatch\_mig\_service, as well as the calling out functions in runloop, will finish works one by one in a loop without blocking between them.
This procedure to discover such programming paradigm can be repeated on regular executions before tracing for diagnosis.
On the contrary, the missing connections are much harder to explore.
As long as the remaining connections in the current graph help diagnosis, it is not necessary to explore.
