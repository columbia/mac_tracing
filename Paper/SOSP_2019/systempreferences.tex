\subsection{System Preferences}

System Preferences is widely used in MacOS for customizing the system settings.
The display panel there helps users to extend there workspace with additional
minitors. However, it can not deactivate monitors online without unplug it.
DisableMonitor is distributed via github to complete the function. Surprisingly,
it exposes a performance bug in System Preferences when we disable an external
monitor, and rearrange the windows in the display panel afterward. The window of
System Preferences freezes for seconds in the situation.

We arrange the displayers with all active monitors, and repeat the process with
one of them deactivated. Argus collects 132MB data, and constructs dependency
graph system-wide in the period, which contains 428,785 vertexes and 320,554
edges.

To diagnose the root cause, Argus first finds out when the NSEvent thread in
System Preferences notifies WindowServer to draw the spinning cursor and marks
it as \textit{t}. The node in the main UI thread causing the non-responsiveness
must overlap the time interval \textit{(t - 2s, t)}. It is not hard for
Argus to tell the spinning node in the main UI thread, either busy processing or
blocking.

The spinning node in the main UI thread is dominated by \textit{mach\_msg} and
\textit{thread\_switch}, both of which are meant to wait for available data
ping from WindowServer. Noticing the timeouts of \text{thread\_switch}, Argus
classifies this case into the third category (\S\ref{subsec:debug}) and heads
to find a comparable normal node in the same thread. As its semantics is not
descriptive enough to identify its comparable node, Argus extends the comparison
with its proceeding nodes.

In the normal case, System Preferences gets rid of the thread\_switch
quickly after receiving messages from WindowServer. It proceeds
to \textit{displayReconfigured}. On the contrary, the spinning
node ends up sending message for the available datagram ping with
\textit{CGSSnarfAndDispatchDatagrams}. By checking the lightweight callstacks,
Argus figures out the messages from WindowServer in the previous nodes are
responses to data avialable pings from \textit{activeDisplayNotificationHandler}.

Given the information, we launched the interactive debugging by 
feeding the debugging script with those APIs mentioned above. We set the method
\textit{activeDisplayNotificationHandler} as a beakpoint where the script begins
debugging. \textit{displayReconfigured} and \textit{CGSSnarfAndDispatchDatagrams}
are used to indicate the end of debugging for the normal case and spinning case
respectively.

By diff the two logs, we notice the different branches in
\textit{display\_notify\_proc} called by \textit{activeDisplayNotificationHandler}. 
They depend on their received datagrams. In normal case, the datagram makes the
System Preference finish the display reconfiguration, while in the spinning case
such datagram is never received, which results in the repeating thread\_switch.
As a conclusion, the handler \textit{display\_notify\_proc} is not appropriately
implemented.
