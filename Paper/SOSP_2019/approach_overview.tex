\section{Approach Overview}
The XXX prototype is designed to expose the thread relationships with temporal constraints and further allow analysis toolkit built on for diagnosis.
Workloads running on MacOS usually send requests to various sets of daemons.
One request can take paths through multiple daemons, while one daemon can also accept a batch of comming tasks and demultiplex them.
Our framework records the system-wide activities with minimal instrumentation and constructs the thread relationship with the implicit schema from them.

\subsection{Instrumentation}
XXX instrumentation leverages the tracing technology from Apple's event logging infrastructure.
An event consists of a timestamp, an event type name to notate current activity and arbitrary attributes.
The API that produces a stream of timestamped events of an event type is called a tracing point.
The goal of our Instrumentation is to attach the tracing points in significant spots where the system state can be captured.
There are three main categories of tracing points:
\begin {enumerate}
	\item Tracing points implies the relationship across thread boundaries.
	\item Tracing points identifies the requests boundaries inside a thread.
	\item Tracing points improves the comprehension of the system activity.
\end{enumerate}
Most of them are from the kernel which is open source and pre-existing in the current version of MacOS.
We augment them with more attributes to support our extensive use.
Libraries and frameworks providing batch processing programming paradigms are instrumented to detangle multiple requests.
We can instrument anywhere if necessary, but rarely touch the user space to allow our toolkits more general.
\subsection{Graphs Construction}
In the process of graphs construction, we extract the built-in event schema that indicates how a subset of events connected, and if an event acts as a delimiter that implies a thread reaches the beginning or end of a request.
We link the threads with connections defined in the subset of events and split the threads with the implied delimiters.
A thread is split into multiple execution segments, decomplexing the execution of different requests on the thread.
Consequently, multiple graphs are generated with the execution segment as a node and the links among them as the edge.
They represent the system activities.

However, the graphs constructed with event schema is neither accurate nor complete.
%%TODO: add reference of magpie and AppInsight
The missing connections may be caused by shared variables which are widely used for the synchronizations among threads, which is exhaustive to explore.
On the other hand, the delimiters are not explicit somewhere due to undocumented programming paradigms.
For example, a batch processing programming paradigm is not uncommon in current systems from user-defined server thread to the kernel thread.
The relationship between a thread waits, and another thread wakes it up later, are not equal to the dependency between them.
To improve the constructed graphs, we come up with an ad-hoc hardware watchpoint tool to monitor shared variables and heuristics to XXXXXXXXXXXXXXXX
We present the details in the following sections.

\subsection{Analysis Toolkit}
With the graphs generated, analysis tools can be built on for various purposes, studying requests, comparison multiple executions or retrieve the bug paths.
Some design mechanism can be revealed with the graphs.
Our roughly generated graph on a toy app used particular API tells how the API gets implemented and what daemons are accessed to complete it.
For example, the NSLog is implemented by sending messages to the server.
%TODO: add details here on NSLog thing
The design of the spinning cursor in MacOS is tapped by checking the path that triggers spindump.
Timestamps carried by the tracing events helps to calculate the time cost of the execution segments, as well as the blocking time of a thread on specific resources.
By checking the long execution segments or the long time blocking in UI thread, users can confine the performance anomaly to the execution interval.
